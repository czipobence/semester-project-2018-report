\section{Correctness Equivalence}
We only checked two aspects of validity of stainless programs, so let us define validity accordingly
\begin{definition}[Stainless-validity]
	A Stainless program $p$ is valid if
	
	\begin{itemize}
		\item the preconditions hold for every call of $f$
		\item for any input satisfying the preconditions, the postcondition holds
	\end{itemize}

In stainless, pre- and postconditions can be expressed as evaluating a boolean condition, and if the condition does not hold, go into an error branch. So in other terms, $p$ is correct, if these error branches are never active.
\end{definition}

Errors are translated to Coq using contradiction: $\tr{\text{error}} = \text{contradiction} ~ \_$

Contradictions can be expressed as the obligation to generate false.

\begin{lstlisting}[style=myCoqstyle]
Definition contradiction (T: Type)(p: False) : T := match p with end.
\end{lstlisting} 

Applying \coqInline{contradiction} on an unknown variable will result in an obligation to derive \coqInline{False} from the context.

\begin{definition}[Coq-validity]
	A Coq program $p$ is valid if there is a proof (an expression of that type) for every obligation generated by it.
\end{definition}

The goal of the translation presented in Section~\ref{sect:trans} was to be able to reason about the validity (or correctness) of the original Stainless program, based on the validity of the translated Coq representation.

\begin{theorem}
	For every (correctly typed) Stainless program $p$ and its translation $\tr{p}$, if $\tr{p}$ is proved to be valid by Coq, than $p$ is also valid.
\end{theorem}

Instead of proving this we will just sketch some notions why is it true.

\begin{assumption}
	\label{ass:bools}
	For every every Scala term \scalaInline{b: Boolean} we assume that if $b \reduceTo c$ where $c \in \{\text{true}, \text{false}\}$ then $\tr{b} \reduceToCoq \tr{c}$, so if b evaluates to a boolean constant in Stainless (under the context $\Gamma$), its translated representation evaluate to the representation of that boolean constant in Coq (under the context $\tr{\Gamma}$).
\end{assumption}

Let us examine only the cases where every decision in the program $p$ is a branching based on a boolean variable. We will also assume that $p$ does not have any free variables. 
Our statement can be proved by contradiction, assuming that $\tr{p}$ is proven to be correct, but $p$ crashes. In this case, there is a branch in p that contains error, and it is accessed through evaluating the boolean expressions $b_1, b_2 \ldots b_n$. We can apply Assumption~\ref{ass:bools}, add conclude that $\tr{p}$ reduces to the same branch. We know that Coq was able to verify $\tr{p}$, which means it was able to prove the obligation that was generated by contradiction. This means that we had $\{\} \vdash x: False$ as hypothesis.

Here, we can use two facts:

\begin{fact}
	In Coq, if $\{\} \vdash t: T$, then $t \reduceToCoq v$, where v is a value of $T$
\end{fact}
\begin{fact}
	There is no value of type \coqInline{False}.
\end{fact}

We have reached contradiction, so we have "proved" our statement.


% Not so clear with params, e.g. functions